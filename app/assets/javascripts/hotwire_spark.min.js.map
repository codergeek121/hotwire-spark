{"version":3,"file":"hotwire_spark.min.js","sources":["../../javascript/hotwire/spark/helpers.js","../../javascript/hotwire/spark/config.js","../../../node_modules/@rails/actioncable/app/assets/javascripts/actioncable.esm.js","../../javascript/hotwire/spark/channels/consumer.js","../../../node_modules/idiomorph/dist/idiomorph.esm.js","../../javascript/hotwire/spark/logger.js","../../javascript/hotwire/spark/reloaders/stimulus_reloader.js","../../javascript/hotwire/spark/reloaders/morph_html_reloader.js","../../javascript/hotwire/spark/reloaders/css_reloader.js","../../javascript/hotwire/spark/reloaders/replace_html_reloader.js","../../javascript/hotwire/spark/channels/monitoring_channel.js","../../javascript/hotwire/spark/index.js"],"sourcesContent":["export function assetNameFromPath(path) {\n  return path.split(\"/\").pop().split(\".\")[0]\n}\n\nexport function pathWithoutAssetDigest(path) {\n  return path.replace(/-[a-z0-9]+\\.(\\w+)(\\?.*)?$/, \".$1\")\n}\n\nexport function urlWithParams(urlString, params) {\n  const url = new URL(urlString, window.location.origin)\n  Object.entries(params).forEach(([ key, value ]) => {\n    url.searchParams.set(key, value)\n  })\n  return url.toString()\n}\n\nexport function cacheBustedUrl(urlString) {\n  return urlWithParams(urlString, { reload: Date.now() })\n}\n\nexport async function reloadHtmlDocument() {\n  let currentUrl = cacheBustedUrl(urlWithParams(window.location.href, { hotwire_spark: \"true\" }))\n  const response = await fetch(currentUrl, { headers: { \"Accept\": \"text/html\" }})\n\n  if (!response.ok) {\n    throw new Error(`${response.status} when fetching ${currentUrl}`)\n  }\n\n  const fetchedHTML = await response.text()\n  const parser = new DOMParser()\n  return parser.parseFromString(fetchedHTML, \"text/html\")\n}\n\nexport function getConfigurationProperty(name) {\n  return document.querySelector(`meta[name=\"hotwire-spark:${name}\"]`)?.content\n}\n\n","import { getConfigurationProperty } from \"./helpers.js\";\n\nexport default {\n  loggingEnabled: getConfigurationProperty(\"logging\") ?? false,\n  htmlReloadMethod: getConfigurationProperty(\"html-reload-method\"),\n  cableServerPath: getConfigurationProperty(\"cable-server-path\"),\n}\n","var adapters = {\n  logger: typeof console !== \"undefined\" ? console : undefined,\n  WebSocket: typeof WebSocket !== \"undefined\" ? WebSocket : undefined\n};\n\nvar logger = {\n  log(...messages) {\n    if (this.enabled) {\n      messages.push(Date.now());\n      adapters.logger.log(\"[ActionCable]\", ...messages);\n    }\n  }\n};\n\nconst now = () => (new Date).getTime();\n\nconst secondsSince = time => (now() - time) / 1e3;\n\nclass ConnectionMonitor {\n  constructor(connection) {\n    this.visibilityDidChange = this.visibilityDidChange.bind(this);\n    this.connection = connection;\n    this.reconnectAttempts = 0;\n  }\n  start() {\n    if (!this.isRunning()) {\n      this.startedAt = now();\n      delete this.stoppedAt;\n      this.startPolling();\n      addEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);\n    }\n  }\n  stop() {\n    if (this.isRunning()) {\n      this.stoppedAt = now();\n      this.stopPolling();\n      removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(\"ConnectionMonitor stopped\");\n    }\n  }\n  isRunning() {\n    return this.startedAt && !this.stoppedAt;\n  }\n  recordMessage() {\n    this.pingedAt = now();\n  }\n  recordConnect() {\n    this.reconnectAttempts = 0;\n    delete this.disconnectedAt;\n    logger.log(\"ConnectionMonitor recorded connect\");\n  }\n  recordDisconnect() {\n    this.disconnectedAt = now();\n    logger.log(\"ConnectionMonitor recorded disconnect\");\n  }\n  startPolling() {\n    this.stopPolling();\n    this.poll();\n  }\n  stopPolling() {\n    clearTimeout(this.pollTimeout);\n  }\n  poll() {\n    this.pollTimeout = setTimeout((() => {\n      this.reconnectIfStale();\n      this.poll();\n    }), this.getPollInterval());\n  }\n  getPollInterval() {\n    const {staleThreshold: staleThreshold, reconnectionBackoffRate: reconnectionBackoffRate} = this.constructor;\n    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));\n    const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;\n    const jitter = jitterMax * Math.random();\n    return staleThreshold * 1e3 * backoff * (1 + jitter);\n  }\n  reconnectIfStale() {\n    if (this.connectionIsStale()) {\n      logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);\n      this.reconnectAttempts++;\n      if (this.disconnectedRecently()) {\n        logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);\n      } else {\n        logger.log(\"ConnectionMonitor reopening\");\n        this.connection.reopen();\n      }\n    }\n  }\n  get refreshedAt() {\n    return this.pingedAt ? this.pingedAt : this.startedAt;\n  }\n  connectionIsStale() {\n    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;\n  }\n  disconnectedRecently() {\n    return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n  }\n  visibilityDidChange() {\n    if (document.visibilityState === \"visible\") {\n      setTimeout((() => {\n        if (this.connectionIsStale() || !this.connection.isOpen()) {\n          logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);\n          this.connection.reopen();\n        }\n      }), 200);\n    }\n  }\n}\n\nConnectionMonitor.staleThreshold = 6;\n\nConnectionMonitor.reconnectionBackoffRate = .15;\n\nvar INTERNAL = {\n  message_types: {\n    welcome: \"welcome\",\n    disconnect: \"disconnect\",\n    ping: \"ping\",\n    confirmation: \"confirm_subscription\",\n    rejection: \"reject_subscription\"\n  },\n  disconnect_reasons: {\n    unauthorized: \"unauthorized\",\n    invalid_request: \"invalid_request\",\n    server_restart: \"server_restart\",\n    remote: \"remote\"\n  },\n  default_mount_path: \"/cable\",\n  protocols: [ \"actioncable-v1-json\", \"actioncable-unsupported\" ]\n};\n\nconst {message_types: message_types, protocols: protocols} = INTERNAL;\n\nconst supportedProtocols = protocols.slice(0, protocols.length - 1);\n\nconst indexOf = [].indexOf;\n\nclass Connection {\n  constructor(consumer) {\n    this.open = this.open.bind(this);\n    this.consumer = consumer;\n    this.subscriptions = this.consumer.subscriptions;\n    this.monitor = new ConnectionMonitor(this);\n    this.disconnected = true;\n  }\n  send(data) {\n    if (this.isOpen()) {\n      this.webSocket.send(JSON.stringify(data));\n      return true;\n    } else {\n      return false;\n    }\n  }\n  open() {\n    if (this.isActive()) {\n      logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);\n      return false;\n    } else {\n      const socketProtocols = [ ...protocols, ...this.consumer.subprotocols || [] ];\n      logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);\n      if (this.webSocket) {\n        this.uninstallEventHandlers();\n      }\n      this.webSocket = new adapters.WebSocket(this.consumer.url, socketProtocols);\n      this.installEventHandlers();\n      this.monitor.start();\n      return true;\n    }\n  }\n  close({allowReconnect: allowReconnect} = {\n    allowReconnect: true\n  }) {\n    if (!allowReconnect) {\n      this.monitor.stop();\n    }\n    if (this.isOpen()) {\n      return this.webSocket.close();\n    }\n  }\n  reopen() {\n    logger.log(`Reopening WebSocket, current state is ${this.getState()}`);\n    if (this.isActive()) {\n      try {\n        return this.close();\n      } catch (error) {\n        logger.log(\"Failed to reopen WebSocket\", error);\n      } finally {\n        logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);\n        setTimeout(this.open, this.constructor.reopenDelay);\n      }\n    } else {\n      return this.open();\n    }\n  }\n  getProtocol() {\n    if (this.webSocket) {\n      return this.webSocket.protocol;\n    }\n  }\n  isOpen() {\n    return this.isState(\"open\");\n  }\n  isActive() {\n    return this.isState(\"open\", \"connecting\");\n  }\n  triedToReconnect() {\n    return this.monitor.reconnectAttempts > 0;\n  }\n  isProtocolSupported() {\n    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;\n  }\n  isState(...states) {\n    return indexOf.call(states, this.getState()) >= 0;\n  }\n  getState() {\n    if (this.webSocket) {\n      for (let state in adapters.WebSocket) {\n        if (adapters.WebSocket[state] === this.webSocket.readyState) {\n          return state.toLowerCase();\n        }\n      }\n    }\n    return null;\n  }\n  installEventHandlers() {\n    for (let eventName in this.events) {\n      const handler = this.events[eventName].bind(this);\n      this.webSocket[`on${eventName}`] = handler;\n    }\n  }\n  uninstallEventHandlers() {\n    for (let eventName in this.events) {\n      this.webSocket[`on${eventName}`] = function() {};\n    }\n  }\n}\n\nConnection.reopenDelay = 500;\n\nConnection.prototype.events = {\n  message(event) {\n    if (!this.isProtocolSupported()) {\n      return;\n    }\n    const {identifier: identifier, message: message, reason: reason, reconnect: reconnect, type: type} = JSON.parse(event.data);\n    this.monitor.recordMessage();\n    switch (type) {\n     case message_types.welcome:\n      if (this.triedToReconnect()) {\n        this.reconnectAttempted = true;\n      }\n      this.monitor.recordConnect();\n      return this.subscriptions.reload();\n\n     case message_types.disconnect:\n      logger.log(`Disconnecting. Reason: ${reason}`);\n      return this.close({\n        allowReconnect: reconnect\n      });\n\n     case message_types.ping:\n      return null;\n\n     case message_types.confirmation:\n      this.subscriptions.confirmSubscription(identifier);\n      if (this.reconnectAttempted) {\n        this.reconnectAttempted = false;\n        return this.subscriptions.notify(identifier, \"connected\", {\n          reconnected: true\n        });\n      } else {\n        return this.subscriptions.notify(identifier, \"connected\", {\n          reconnected: false\n        });\n      }\n\n     case message_types.rejection:\n      return this.subscriptions.reject(identifier);\n\n     default:\n      return this.subscriptions.notify(identifier, \"received\", message);\n    }\n  },\n  open() {\n    logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);\n    this.disconnected = false;\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n      return this.close({\n        allowReconnect: false\n      });\n    }\n  },\n  close(event) {\n    logger.log(\"WebSocket onclose event\");\n    if (this.disconnected) {\n      return;\n    }\n    this.disconnected = true;\n    this.monitor.recordDisconnect();\n    return this.subscriptions.notifyAll(\"disconnected\", {\n      willAttemptReconnect: this.monitor.isRunning()\n    });\n  },\n  error() {\n    logger.log(\"WebSocket onerror event\");\n  }\n};\n\nconst extend = function(object, properties) {\n  if (properties != null) {\n    for (let key in properties) {\n      const value = properties[key];\n      object[key] = value;\n    }\n  }\n  return object;\n};\n\nclass Subscription {\n  constructor(consumer, params = {}, mixin) {\n    this.consumer = consumer;\n    this.identifier = JSON.stringify(params);\n    extend(this, mixin);\n  }\n  perform(action, data = {}) {\n    data.action = action;\n    return this.send(data);\n  }\n  send(data) {\n    return this.consumer.send({\n      command: \"message\",\n      identifier: this.identifier,\n      data: JSON.stringify(data)\n    });\n  }\n  unsubscribe() {\n    return this.consumer.subscriptions.remove(this);\n  }\n}\n\nclass SubscriptionGuarantor {\n  constructor(subscriptions) {\n    this.subscriptions = subscriptions;\n    this.pendingSubscriptions = [];\n  }\n  guarantee(subscription) {\n    if (this.pendingSubscriptions.indexOf(subscription) == -1) {\n      logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);\n      this.pendingSubscriptions.push(subscription);\n    } else {\n      logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);\n    }\n    this.startGuaranteeing();\n  }\n  forget(subscription) {\n    logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);\n    this.pendingSubscriptions = this.pendingSubscriptions.filter((s => s !== subscription));\n  }\n  startGuaranteeing() {\n    this.stopGuaranteeing();\n    this.retrySubscribing();\n  }\n  stopGuaranteeing() {\n    clearTimeout(this.retryTimeout);\n  }\n  retrySubscribing() {\n    this.retryTimeout = setTimeout((() => {\n      if (this.subscriptions && typeof this.subscriptions.subscribe === \"function\") {\n        this.pendingSubscriptions.map((subscription => {\n          logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);\n          this.subscriptions.subscribe(subscription);\n        }));\n      }\n    }), 500);\n  }\n}\n\nclass Subscriptions {\n  constructor(consumer) {\n    this.consumer = consumer;\n    this.guarantor = new SubscriptionGuarantor(this);\n    this.subscriptions = [];\n  }\n  create(channelName, mixin) {\n    const channel = channelName;\n    const params = typeof channel === \"object\" ? channel : {\n      channel: channel\n    };\n    const subscription = new Subscription(this.consumer, params, mixin);\n    return this.add(subscription);\n  }\n  add(subscription) {\n    this.subscriptions.push(subscription);\n    this.consumer.ensureActiveConnection();\n    this.notify(subscription, \"initialized\");\n    this.subscribe(subscription);\n    return subscription;\n  }\n  remove(subscription) {\n    this.forget(subscription);\n    if (!this.findAll(subscription.identifier).length) {\n      this.sendCommand(subscription, \"unsubscribe\");\n    }\n    return subscription;\n  }\n  reject(identifier) {\n    return this.findAll(identifier).map((subscription => {\n      this.forget(subscription);\n      this.notify(subscription, \"rejected\");\n      return subscription;\n    }));\n  }\n  forget(subscription) {\n    this.guarantor.forget(subscription);\n    this.subscriptions = this.subscriptions.filter((s => s !== subscription));\n    return subscription;\n  }\n  findAll(identifier) {\n    return this.subscriptions.filter((s => s.identifier === identifier));\n  }\n  reload() {\n    return this.subscriptions.map((subscription => this.subscribe(subscription)));\n  }\n  notifyAll(callbackName, ...args) {\n    return this.subscriptions.map((subscription => this.notify(subscription, callbackName, ...args)));\n  }\n  notify(subscription, callbackName, ...args) {\n    let subscriptions;\n    if (typeof subscription === \"string\") {\n      subscriptions = this.findAll(subscription);\n    } else {\n      subscriptions = [ subscription ];\n    }\n    return subscriptions.map((subscription => typeof subscription[callbackName] === \"function\" ? subscription[callbackName](...args) : undefined));\n  }\n  subscribe(subscription) {\n    if (this.sendCommand(subscription, \"subscribe\")) {\n      this.guarantor.guarantee(subscription);\n    }\n  }\n  confirmSubscription(identifier) {\n    logger.log(`Subscription confirmed ${identifier}`);\n    this.findAll(identifier).map((subscription => this.guarantor.forget(subscription)));\n  }\n  sendCommand(subscription, command) {\n    const {identifier: identifier} = subscription;\n    return this.consumer.send({\n      command: command,\n      identifier: identifier\n    });\n  }\n}\n\nclass Consumer {\n  constructor(url) {\n    this._url = url;\n    this.subscriptions = new Subscriptions(this);\n    this.connection = new Connection(this);\n    this.subprotocols = [];\n  }\n  get url() {\n    return createWebSocketURL(this._url);\n  }\n  send(data) {\n    return this.connection.send(data);\n  }\n  connect() {\n    return this.connection.open();\n  }\n  disconnect() {\n    return this.connection.close({\n      allowReconnect: false\n    });\n  }\n  ensureActiveConnection() {\n    if (!this.connection.isActive()) {\n      return this.connection.open();\n    }\n  }\n  addSubProtocol(subprotocol) {\n    this.subprotocols = [ ...this.subprotocols, subprotocol ];\n  }\n}\n\nfunction createWebSocketURL(url) {\n  if (typeof url === \"function\") {\n    url = url();\n  }\n  if (url && !/^wss?:/i.test(url)) {\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.href = a.href;\n    a.protocol = a.protocol.replace(\"http\", \"ws\");\n    return a.href;\n  } else {\n    return url;\n  }\n}\n\nfunction createConsumer(url = getConfig(\"url\") || INTERNAL.default_mount_path) {\n  return new Consumer(url);\n}\n\nfunction getConfig(name) {\n  const element = document.head.querySelector(`meta[name='action-cable-${name}']`);\n  if (element) {\n    return element.getAttribute(\"content\");\n  }\n}\n\nexport { Connection, ConnectionMonitor, Consumer, INTERNAL, Subscription, SubscriptionGuarantor, Subscriptions, adapters, createConsumer, createWebSocketURL, getConfig, logger };\n","import { createConsumer } from \"@rails/actioncable\"\nimport config from \"../config\"\n\nexport default createConsumer(config.cableServerPath)\n","// base IIFE to define idiomorph\nvar Idiomorph = (function () {\n        'use strict';\n\n        //=============================================================================\n        // AND NOW IT BEGINS...\n        //=============================================================================\n        let EMPTY_SET = new Set();\n\n        // default configuration values, updatable by users now\n        let defaults = {\n            morphStyle: \"outerHTML\",\n            callbacks : {\n                beforeNodeAdded: noOp,\n                afterNodeAdded: noOp,\n                beforeNodeMorphed: noOp,\n                afterNodeMorphed: noOp,\n                beforeNodeRemoved: noOp,\n                afterNodeRemoved: noOp,\n                beforeAttributeUpdated: noOp,\n\n            },\n            head: {\n                style: 'merge',\n                shouldPreserve: function (elt) {\n                    return elt.getAttribute(\"im-preserve\") === \"true\";\n                },\n                shouldReAppend: function (elt) {\n                    return elt.getAttribute(\"im-re-append\") === \"true\";\n                },\n                shouldRemove: noOp,\n                afterHeadMorphed: noOp,\n            }\n        };\n\n        //=============================================================================\n        // Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n        //=============================================================================\n        function morph(oldNode, newContent, config = {}) {\n\n            if (oldNode instanceof Document) {\n                oldNode = oldNode.documentElement;\n            }\n\n            if (typeof newContent === 'string') {\n                newContent = parseContent(newContent);\n            }\n\n            let normalizedContent = normalizeContent(newContent);\n\n            let ctx = createMorphContext(oldNode, normalizedContent, config);\n\n            return morphNormalizedContent(oldNode, normalizedContent, ctx);\n        }\n\n        function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {\n            if (ctx.head.block) {\n                let oldHead = oldNode.querySelector('head');\n                let newHead = normalizedNewContent.querySelector('head');\n                if (oldHead && newHead) {\n                    let promises = handleHeadElement(newHead, oldHead, ctx);\n                    // when head promises resolve, call morph again, ignoring the head tag\n                    Promise.all(promises).then(function () {\n                        morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {\n                            head: {\n                                block: false,\n                                ignore: true\n                            }\n                        }));\n                    });\n                    return;\n                }\n            }\n\n            if (ctx.morphStyle === \"innerHTML\") {\n\n                // innerHTML, so we are only updating the children\n                morphChildren(normalizedNewContent, oldNode, ctx);\n                return oldNode.children;\n\n            } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n                // otherwise find the best element match in the new content, morph that, and merge its siblings\n                // into either side of the best match\n                let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n                // stash the siblings that will need to be inserted on either side of the best match\n                let previousSibling = bestMatch?.previousSibling;\n                let nextSibling = bestMatch?.nextSibling;\n\n                // morph it\n                let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n                if (bestMatch) {\n                    // if there was a best match, merge the siblings in too and return the\n                    // whole bunch\n                    return insertSiblings(previousSibling, morphedNode, nextSibling);\n                } else {\n                    // otherwise nothing was added to the DOM\n                    return []\n                }\n            } else {\n                throw \"Do not understand how to morph style \" + ctx.morphStyle;\n            }\n        }\n\n\n        /**\n         * @param possibleActiveElement\n         * @param ctx\n         * @returns {boolean}\n         */\n        function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n            return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement;\n        }\n\n        /**\n         * @param oldNode root node to merge content into\n         * @param newContent new content to merge\n         * @param ctx the merge context\n         * @returns {Element} the element that ended up in the DOM\n         */\n        function morphOldNodeTo(oldNode, newContent, ctx) {\n            if (ctx.ignoreActive && oldNode === document.activeElement) {\n                // don't morph focused element\n            } else if (newContent == null) {\n                if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n\n                oldNode.remove();\n                ctx.callbacks.afterNodeRemoved(oldNode);\n                return null;\n            } else if (!isSoftMatch(oldNode, newContent)) {\n                if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n                if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;\n\n                oldNode.parentElement.replaceChild(newContent, oldNode);\n                ctx.callbacks.afterNodeAdded(newContent);\n                ctx.callbacks.afterNodeRemoved(oldNode);\n                return newContent;\n            } else {\n                if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;\n\n                if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n                    // ignore the head element\n                } else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== \"morph\") {\n                    handleHeadElement(newContent, oldNode, ctx);\n                } else {\n                    syncNodeFrom(newContent, oldNode, ctx);\n                    if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n                        morphChildren(newContent, oldNode, ctx);\n                    }\n                }\n                ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n                return oldNode;\n            }\n        }\n\n        /**\n         * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n         * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n         * by using id sets, we are able to better match up with content deeper in the DOM.\n         *\n         * Basic algorithm is, for each node in the new content:\n         *\n         * - if we have reached the end of the old parent, append the new content\n         * - if the new content has an id set match with the current insertion point, morph\n         * - search for an id set match\n         * - if id set match found, morph\n         * - otherwise search for a \"soft\" match\n         * - if a soft match is found, morph\n         * - otherwise, prepend the new node before the current insertion point\n         *\n         * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n         * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n         *\n         * @param {Element} newParent the parent element of the new content\n         * @param {Element } oldParent the old content that we are merging the new content into\n         * @param ctx the merge context\n         */\n        function morphChildren(newParent, oldParent, ctx) {\n\n            let nextNewChild = newParent.firstChild;\n            let insertionPoint = oldParent.firstChild;\n            let newChild;\n\n            // run through all the new content\n            while (nextNewChild) {\n\n                newChild = nextNewChild;\n                nextNewChild = newChild.nextSibling;\n\n                // if we are at the end of the exiting parent's children, just append\n                if (insertionPoint == null) {\n                    if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n                    oldParent.appendChild(newChild);\n                    ctx.callbacks.afterNodeAdded(newChild);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // if the current node has an id set match then morph\n                if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n                    morphOldNodeTo(insertionPoint, newChild, ctx);\n                    insertionPoint = insertionPoint.nextSibling;\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // otherwise search forward in the existing old children for an id set match\n                let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                // if we found a potential match, remove the nodes until that point and morph\n                if (idSetMatch) {\n                    insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n                    morphOldNodeTo(idSetMatch, newChild, ctx);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // no id set match found, so scan forward for a soft match for the current node\n                let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                // if we found a soft match for the current node, morph\n                if (softMatch) {\n                    insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n                    morphOldNodeTo(softMatch, newChild, ctx);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // abandon all hope of morphing, just insert the new child before the insertion point\n                // and move on\n                if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n                oldParent.insertBefore(newChild, insertionPoint);\n                ctx.callbacks.afterNodeAdded(newChild);\n                removeIdsFromConsideration(ctx, newChild);\n            }\n\n            // remove any remaining old nodes that didn't match up with new content\n            while (insertionPoint !== null) {\n\n                let tempNode = insertionPoint;\n                insertionPoint = insertionPoint.nextSibling;\n                removeNode(tempNode, ctx);\n            }\n        }\n\n        //=============================================================================\n        // Attribute Syncing Code\n        //=============================================================================\n\n        /**\n         * @param attr {String} the attribute to be mutated\n         * @param to {Element} the element that is going to be updated\n         * @param updateType {(\"update\"|\"remove\")}\n         * @param ctx the merge context\n         * @returns {boolean} true if the attribute should be ignored, false otherwise\n         */\n        function ignoreAttribute(attr, to, updateType, ctx) {\n            if(attr === 'value' && ctx.ignoreActiveValue && to === document.activeElement){\n                return true;\n            }\n            return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;\n        }\n\n        /**\n         * syncs a given node with another node, copying over all attributes and\n         * inner element state from the 'from' node to the 'to' node\n         *\n         * @param {Element} from the element to copy attributes & state from\n         * @param {Element} to the element to copy attributes & state to\n         * @param ctx the merge context\n         */\n        function syncNodeFrom(from, to, ctx) {\n            let type = from.nodeType\n\n            // if is an element type, sync the attributes from the\n            // new node into the new node\n            if (type === 1 /* element type */) {\n                const fromAttributes = from.attributes;\n                const toAttributes = to.attributes;\n                for (const fromAttribute of fromAttributes) {\n                    if (ignoreAttribute(fromAttribute.name, to, 'update', ctx)) {\n                        continue;\n                    }\n                    if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n                        to.setAttribute(fromAttribute.name, fromAttribute.value);\n                    }\n                }\n                // iterate backwards to avoid skipping over items when a delete occurs\n                for (let i = toAttributes.length - 1; 0 <= i; i--) {\n                    const toAttribute = toAttributes[i];\n                    if (ignoreAttribute(toAttribute.name, to, 'remove', ctx)) {\n                        continue;\n                    }\n                    if (!from.hasAttribute(toAttribute.name)) {\n                        to.removeAttribute(toAttribute.name);\n                    }\n                }\n            }\n\n            // sync text nodes\n            if (type === 8 /* comment */ || type === 3 /* text */) {\n                if (to.nodeValue !== from.nodeValue) {\n                    to.nodeValue = from.nodeValue;\n                }\n            }\n\n            if (!ignoreValueOfActiveElement(to, ctx)) {\n                // sync input values\n                syncInputValue(from, to, ctx);\n            }\n        }\n\n        /**\n         * @param from {Element} element to sync the value from\n         * @param to {Element} element to sync the value to\n         * @param attributeName {String} the attribute name\n         * @param ctx the merge context\n         */\n        function syncBooleanAttribute(from, to, attributeName, ctx) {\n            if (from[attributeName] !== to[attributeName]) {\n                let ignoreUpdate = ignoreAttribute(attributeName, to, 'update', ctx);\n                if (!ignoreUpdate) {\n                    to[attributeName] = from[attributeName];\n                }\n                if (from[attributeName]) {\n                    if (!ignoreUpdate) {\n                        to.setAttribute(attributeName, from[attributeName]);\n                    }\n                } else {\n                    if (!ignoreAttribute(attributeName, to, 'remove', ctx)) {\n                        to.removeAttribute(attributeName);\n                    }\n                }\n            }\n        }\n\n        /**\n         * NB: many bothans died to bring us information:\n         *\n         *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n         *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n         *\n         * @param from {Element} the element to sync the input value from\n         * @param to {Element} the element to sync the input value to\n         * @param ctx the merge context\n         */\n        function syncInputValue(from, to, ctx) {\n            if (from instanceof HTMLInputElement &&\n                to instanceof HTMLInputElement &&\n                from.type !== 'file') {\n\n                let fromValue = from.value;\n                let toValue = to.value;\n\n                // sync boolean attributes\n                syncBooleanAttribute(from, to, 'checked', ctx);\n                syncBooleanAttribute(from, to, 'disabled', ctx);\n\n                if (!from.hasAttribute('value')) {\n                    if (!ignoreAttribute('value', to, 'remove', ctx)) {\n                        to.value = '';\n                        to.removeAttribute('value');\n                    }\n                } else if (fromValue !== toValue) {\n                    if (!ignoreAttribute('value', to, 'update', ctx)) {\n                        to.setAttribute('value', fromValue);\n                        to.value = fromValue;\n                    }\n                }\n            } else if (from instanceof HTMLOptionElement) {\n                syncBooleanAttribute(from, to, 'selected', ctx)\n            } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n                let fromValue = from.value;\n                let toValue = to.value;\n                if (ignoreAttribute('value', to, 'update', ctx)) {\n                    return;\n                }\n                if (fromValue !== toValue) {\n                    to.value = fromValue;\n                }\n                if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n                    to.firstChild.nodeValue = fromValue\n                }\n            }\n        }\n\n        //=============================================================================\n        // the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n        //=============================================================================\n        function handleHeadElement(newHeadTag, currentHead, ctx) {\n\n            let added = []\n            let removed = []\n            let preserved = []\n            let nodesToAppend = []\n\n            let headMergeStyle = ctx.head.style;\n\n            // put all new head elements into a Map, by their outerHTML\n            let srcToNewHeadNodes = new Map();\n            for (const newHeadChild of newHeadTag.children) {\n                srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n            }\n\n            // for each elt in the current head\n            for (const currentHeadElt of currentHead.children) {\n\n                // If the current head element is in the map\n                let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n                let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n                let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n                if (inNewContent || isPreserved) {\n                    if (isReAppended) {\n                        // remove the current version and let the new version replace it and re-execute\n                        removed.push(currentHeadElt);\n                    } else {\n                        // this element already exists and should not be re-appended, so remove it from\n                        // the new content map, preserving it in the DOM\n                        srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n                        preserved.push(currentHeadElt);\n                    }\n                } else {\n                    if (headMergeStyle === \"append\") {\n                        // we are appending and this existing element is not new content\n                        // so if and only if it is marked for re-append do we do anything\n                        if (isReAppended) {\n                            removed.push(currentHeadElt);\n                            nodesToAppend.push(currentHeadElt);\n                        }\n                    } else {\n                        // if this is a merge, we remove this content since it is not in the new head\n                        if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n                            removed.push(currentHeadElt);\n                        }\n                    }\n                }\n            }\n\n            // Push the remaining new head elements in the Map into the\n            // nodes to append to the head tag\n            nodesToAppend.push(...srcToNewHeadNodes.values());\n            log(\"to append: \", nodesToAppend);\n\n            let promises = [];\n            for (const newNode of nodesToAppend) {\n                log(\"adding: \", newNode);\n                let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;\n                log(newElt);\n                if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n                    if (newElt.href || newElt.src) {\n                        let resolve = null;\n                        let promise = new Promise(function (_resolve) {\n                            resolve = _resolve;\n                        });\n                        newElt.addEventListener('load', function () {\n                            resolve();\n                        });\n                        promises.push(promise);\n                    }\n                    currentHead.appendChild(newElt);\n                    ctx.callbacks.afterNodeAdded(newElt);\n                    added.push(newElt);\n                }\n            }\n\n            // remove all removed elements, after we have appended the new elements to avoid\n            // additional network requests for things like style sheets\n            for (const removedElement of removed) {\n                if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n                    currentHead.removeChild(removedElement);\n                    ctx.callbacks.afterNodeRemoved(removedElement);\n                }\n            }\n\n            ctx.head.afterHeadMorphed(currentHead, {added: added, kept: preserved, removed: removed});\n            return promises;\n        }\n\n        //=============================================================================\n        // Misc\n        //=============================================================================\n\n        function log() {\n            //console.log(arguments);\n        }\n\n        function noOp() {\n        }\n\n        /*\n          Deep merges the config object and the Idiomoroph.defaults object to\n          produce a final configuration object\n         */\n        function mergeDefaults(config) {\n            let finalConfig = {};\n            // copy top level stuff into final config\n            Object.assign(finalConfig, defaults);\n            Object.assign(finalConfig, config);\n\n            // copy callbacks into final config (do this to deep merge the callbacks)\n            finalConfig.callbacks = {};\n            Object.assign(finalConfig.callbacks, defaults.callbacks);\n            Object.assign(finalConfig.callbacks, config.callbacks);\n\n            // copy head config into final config  (do this to deep merge the head)\n            finalConfig.head = {};\n            Object.assign(finalConfig.head, defaults.head);\n            Object.assign(finalConfig.head, config.head);\n            return finalConfig;\n        }\n\n        function createMorphContext(oldNode, newContent, config) {\n            config = mergeDefaults(config);\n            return {\n                target: oldNode,\n                newContent: newContent,\n                config: config,\n                morphStyle: config.morphStyle,\n                ignoreActive: config.ignoreActive,\n                ignoreActiveValue: config.ignoreActiveValue,\n                idMap: createIdMap(oldNode, newContent),\n                deadIds: new Set(),\n                callbacks: config.callbacks,\n                head: config.head\n            }\n        }\n\n        function isIdSetMatch(node1, node2, ctx) {\n            if (node1 == null || node2 == null) {\n                return false;\n            }\n            if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n                if (node1.id !== \"\" && node1.id === node2.id) {\n                    return true;\n                } else {\n                    return getIdIntersectionCount(ctx, node1, node2) > 0;\n                }\n            }\n            return false;\n        }\n\n        function isSoftMatch(node1, node2) {\n            if (node1 == null || node2 == null) {\n                return false;\n            }\n            return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n        }\n\n        function removeNodesBetween(startInclusive, endExclusive, ctx) {\n            while (startInclusive !== endExclusive) {\n                let tempNode = startInclusive;\n                startInclusive = startInclusive.nextSibling;\n                removeNode(tempNode, ctx);\n            }\n            removeIdsFromConsideration(ctx, endExclusive);\n            return endExclusive.nextSibling;\n        }\n\n        //=============================================================================\n        // Scans forward from the insertionPoint in the old parent looking for a potential id match\n        // for the newChild.  We stop if we find a potential id match for the new child OR\n        // if the number of potential id matches we are discarding is greater than the\n        // potential id matches for the new child\n        //=============================================================================\n        function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n            // max id matches we are willing to discard in our search\n            let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);\n\n            let potentialMatch = null;\n\n            // only search forward if there is a possibility of an id match\n            if (newChildPotentialIdCount > 0) {\n                let potentialMatch = insertionPoint;\n                // if there is a possibility of an id match, scan forward\n                // keep track of the potential id match count we are discarding (the\n                // newChildPotentialIdCount must be greater than this to make it likely\n                // worth it)\n                let otherMatchCount = 0;\n                while (potentialMatch != null) {\n\n                    // If we have an id match, return the current potential match\n                    if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n                        return potentialMatch;\n                    }\n\n                    // computer the other potential matches of this new content\n                    otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent);\n                    if (otherMatchCount > newChildPotentialIdCount) {\n                        // if we have more potential id matches in _other_ content, we\n                        // do not have a good candidate for an id match, so return null\n                        return null;\n                    }\n\n                    // advanced to the next old content child\n                    potentialMatch = potentialMatch.nextSibling;\n                }\n            }\n            return potentialMatch;\n        }\n\n        //=============================================================================\n        // Scans forward from the insertionPoint in the old parent looking for a potential soft match\n        // for the newChild.  We stop if we find a potential soft match for the new child OR\n        // if we find a potential id match in the old parents children OR if we find two\n        // potential soft matches for the next two pieces of new content\n        //=============================================================================\n        function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n            let potentialSoftMatch = insertionPoint;\n            let nextSibling = newChild.nextSibling;\n            let siblingSoftMatchCount = 0;\n\n            while (potentialSoftMatch != null) {\n\n                if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n                    // the current potential soft match has a potential id set match with the remaining new\n                    // content so bail out of looking\n                    return null;\n                }\n\n                // if we have a soft match with the current node, return it\n                if (isSoftMatch(newChild, potentialSoftMatch)) {\n                    return potentialSoftMatch;\n                }\n\n                if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n                    // the next new node has a soft match with this node, so\n                    // increment the count of future soft matches\n                    siblingSoftMatchCount++;\n                    nextSibling = nextSibling.nextSibling;\n\n                    // If there are two future soft matches, bail to allow the siblings to soft match\n                    // so that we don't consume future soft matches for the sake of the current node\n                    if (siblingSoftMatchCount >= 2) {\n                        return null;\n                    }\n                }\n\n                // advanced to the next old content child\n                potentialSoftMatch = potentialSoftMatch.nextSibling;\n            }\n\n            return potentialSoftMatch;\n        }\n\n        function parseContent(newContent) {\n            let parser = new DOMParser();\n\n            // remove svgs to avoid false-positive matches on head, etc.\n            let contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '');\n\n            // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n            if (contentWithSvgsRemoved.match(/<\\/html>/) || contentWithSvgsRemoved.match(/<\\/head>/) || contentWithSvgsRemoved.match(/<\\/body>/)) {\n                let content = parser.parseFromString(newContent, \"text/html\");\n                // if it is a full HTML document, return the document itself as the parent container\n                if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n                    content.generatedByIdiomorph = true;\n                    return content;\n                } else {\n                    // otherwise return the html element as the parent container\n                    let htmlElement = content.firstChild;\n                    if (htmlElement) {\n                        htmlElement.generatedByIdiomorph = true;\n                        return htmlElement;\n                    } else {\n                        return null;\n                    }\n                }\n            } else {\n                // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n                // deal with touchy tags like tr, tbody, etc.\n                let responseDoc = parser.parseFromString(\"<body><template>\" + newContent + \"</template></body>\", \"text/html\");\n                let content = responseDoc.body.querySelector('template').content;\n                content.generatedByIdiomorph = true;\n                return content\n            }\n        }\n\n        function normalizeContent(newContent) {\n            if (newContent == null) {\n                // noinspection UnnecessaryLocalVariableJS\n                const dummyParent = document.createElement('div');\n                return dummyParent;\n            } else if (newContent.generatedByIdiomorph) {\n                // the template tag created by idiomorph parsing can serve as a dummy parent\n                return newContent;\n            } else if (newContent instanceof Node) {\n                // a single node is added as a child to a dummy parent\n                const dummyParent = document.createElement('div');\n                dummyParent.append(newContent);\n                return dummyParent;\n            } else {\n                // all nodes in the array or HTMLElement collection are consolidated under\n                // a single dummy parent element\n                const dummyParent = document.createElement('div');\n                for (const elt of [...newContent]) {\n                    dummyParent.append(elt);\n                }\n                return dummyParent;\n            }\n        }\n\n        function insertSiblings(previousSibling, morphedNode, nextSibling) {\n            let stack = []\n            let added = []\n            while (previousSibling != null) {\n                stack.push(previousSibling);\n                previousSibling = previousSibling.previousSibling;\n            }\n            while (stack.length > 0) {\n                let node = stack.pop();\n                added.push(node); // push added preceding siblings on in order and insert\n                morphedNode.parentElement.insertBefore(node, morphedNode);\n            }\n            added.push(morphedNode);\n            while (nextSibling != null) {\n                stack.push(nextSibling);\n                added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n                nextSibling = nextSibling.nextSibling;\n            }\n            while (stack.length > 0) {\n                morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);\n            }\n            return added;\n        }\n\n        function findBestNodeMatch(newContent, oldNode, ctx) {\n            let currentElement;\n            currentElement = newContent.firstChild;\n            let bestElement = currentElement;\n            let score = 0;\n            while (currentElement) {\n                let newScore = scoreElement(currentElement, oldNode, ctx);\n                if (newScore > score) {\n                    bestElement = currentElement;\n                    score = newScore;\n                }\n                currentElement = currentElement.nextSibling;\n            }\n            return bestElement;\n        }\n\n        function scoreElement(node1, node2, ctx) {\n            if (isSoftMatch(node1, node2)) {\n                return .5 + getIdIntersectionCount(ctx, node1, node2);\n            }\n            return 0;\n        }\n\n        function removeNode(tempNode, ctx) {\n            removeIdsFromConsideration(ctx, tempNode)\n            if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n\n            tempNode.remove();\n            ctx.callbacks.afterNodeRemoved(tempNode);\n        }\n\n        //=============================================================================\n        // ID Set Functions\n        //=============================================================================\n\n        function isIdInConsideration(ctx, id) {\n            return !ctx.deadIds.has(id);\n        }\n\n        function idIsWithinNode(ctx, id, targetNode) {\n            let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n            return idSet.has(id);\n        }\n\n        function removeIdsFromConsideration(ctx, node) {\n            let idSet = ctx.idMap.get(node) || EMPTY_SET;\n            for (const id of idSet) {\n                ctx.deadIds.add(id);\n            }\n        }\n\n        function getIdIntersectionCount(ctx, node1, node2) {\n            let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n            let matchCount = 0;\n            for (const id of sourceSet) {\n                // a potential match is an id in the source and potentialIdsSet, but\n                // that has not already been merged into the DOM\n                if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n                    ++matchCount;\n                }\n            }\n            return matchCount;\n        }\n\n        /**\n         * A bottom up algorithm that finds all elements with ids inside of the node\n         * argument and populates id sets for those nodes and all their parents, generating\n         * a set of ids contained within all nodes for the entire hierarchy in the DOM\n         *\n         * @param node {Element}\n         * @param {Map<Node, Set<String>>} idMap\n         */\n        function populateIdMapForNode(node, idMap) {\n            let nodeParent = node.parentElement;\n            // find all elements with an id property\n            let idElements = node.querySelectorAll('[id]');\n            for (const elt of idElements) {\n                let current = elt;\n                // walk up the parent hierarchy of that element, adding the id\n                // of element to the parent's id set\n                while (current !== nodeParent && current != null) {\n                    let idSet = idMap.get(current);\n                    // if the id set doesn't exist, create it and insert it in the  map\n                    if (idSet == null) {\n                        idSet = new Set();\n                        idMap.set(current, idSet);\n                    }\n                    idSet.add(elt.id);\n                    current = current.parentElement;\n                }\n            }\n        }\n\n        /**\n         * This function computes a map of nodes to all ids contained within that node (inclusive of the\n         * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n         * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n         * to contribute to a parent nodes matching.\n         *\n         * @param {Element} oldContent  the old content that will be morphed\n         * @param {Element} newContent  the new content to morph to\n         * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n         */\n        function createIdMap(oldContent, newContent) {\n            let idMap = new Map();\n            populateIdMapForNode(oldContent, idMap);\n            populateIdMapForNode(newContent, idMap);\n            return idMap;\n        }\n\n        //=============================================================================\n        // This is what ends up becoming the Idiomorph global object\n        //=============================================================================\n        return {\n            morph,\n            defaults\n        }\n    })();\n\nexport {Idiomorph};\n","import config from \"./config\"\n\nexport function log(...args) {\n  if (config.loggingEnabled) {\n    console.log(`[hotwire_spark]`, ...args)\n  }\n}\n\n","import { log } from \"../logger.js\"\nimport { cacheBustedUrl, reloadHtmlDocument } from \"../helpers.js\"\n\nexport class StimulusReloader {\n  static async reload(changedFilePath) {\n    const document = await reloadHtmlDocument()\n    return new StimulusReloader(document, changedFilePath).reload()\n  }\n\n  static async reloadAll() {\n    Stimulus.controllers.forEach(controller => {\n      Stimulus.unload(controller.identifier)\n      Stimulus.register(controller.identifier, controller.constructor)\n    })\n\n    return Promise.resolve()\n  }\n\n  constructor(document, changedFilePath) {\n    this.document = document\n    this.changedFilePath = changedFilePath\n    this.application = window.Stimulus\n  }\n\n  async reload() {\n    log(\"Reload Stimulus controllers...\")\n\n    this.application.stop()\n\n    await this.#reloadChangedStimulusControllers()\n    this.#unloadDeletedStimulusControllers()\n\n    this.application.start()\n  }\n\n  async #reloadChangedStimulusControllers() {\n    await Promise.all(\n      this.#stimulusControllerPathsToReload.map(async moduleName => this.#reloadStimulusController(moduleName))\n    )\n  }\n\n  get #stimulusControllerPathsToReload() {\n    this.controllerPathsToReload = this.controllerPathsToReload || this.#stimulusControllerPaths.filter(path => this.#shouldReloadController(path))\n    return this.controllerPathsToReload\n  }\n\n  get #stimulusControllerPaths() {\n    return Object.keys(this.#stimulusPathsByModule).filter(path => path.endsWith(\"_controller\"))\n  }\n\n  #shouldReloadController(path) {\n    return this.#extractControllerName(path) === this.#changedControllerIdentifier\n  }\n\n  get #changedControllerIdentifier() {\n    this.changedControllerIdentifier = this.changedControllerIdentifier || this.#extractControllerName(this.changedFilePath)\n    return this.changedControllerIdentifier\n  }\n\n  get #stimulusPathsByModule() {\n    this.pathsByModule = this.pathsByModule || this.#parseImportmapJson()\n    return this.pathsByModule\n  }\n\n  #parseImportmapJson() {\n    const importmapScript = this.document.querySelector(\"script[type=importmap]\")\n    return JSON.parse(importmapScript.text).imports\n  }\n\n  async #reloadStimulusController(moduleName) {\n    log(`\\t${moduleName}`)\n\n    const controllerName = this.#extractControllerName(moduleName)\n    const path = cacheBustedUrl(this.#pathForModuleName(moduleName))\n\n    const module = await import(path)\n\n    this.#registerController(controllerName, module)\n  }\n\n  #unloadDeletedStimulusControllers() {\n    this.#controllersToUnload.forEach(controller => this.#deregisterController(controller.identifier))\n  }\n\n  get #controllersToUnload() {\n    if (this.#didChangeTriggerAReload) {\n      return []\n    } else {\n      return this.application.controllers.filter(controller => this.#changedControllerIdentifier === controller.identifier)\n    }\n  }\n\n  get #didChangeTriggerAReload() {\n    return this.#stimulusControllerPathsToReload.length > 0\n  }\n\n  #pathForModuleName(moduleName) {\n    return this.#stimulusPathsByModule[moduleName]\n  }\n\n  #extractControllerName(path) {\n    return path\n      .replace(/^\\/+/, \"\")\n      .replace(/^controllers\\//, \"\")\n      .replace(\"_controller\", \"\")\n      .replace(/\\//g, \"--\")\n      .replace(/_/g, \"-\")\n      .replace(/\\.js$/, \"\")\n  }\n\n  #registerController(name, module) {\n    this.application.unload(name)\n    this.application.register(name, module.default)\n  }\n\n  #deregisterController(name) {\n    log(`\\tRemoving controller ${name}`)\n    this.application.unload(name)\n  }\n}\n","import { Idiomorph } from \"idiomorph/dist/idiomorph.esm.js\"\nimport { reloadHtmlDocument } from \"../helpers.js\"\nimport { log } from \"../logger.js\"\nimport { StimulusReloader } from \"./stimulus_reloader.js\"\n\nexport class MorphHtmlReloader {\n  static async reload() {\n    return new MorphHtmlReloader().reload()\n  }\n\n  async reload() {\n    await this.#reloadHtml()\n    await this.#reloadStimulus()\n  }\n\n  async #reloadHtml() {\n    log(\"Reload html with morph...\")\n\n    const reloadedDocument = await reloadHtmlDocument()\n    this.#updateBody(reloadedDocument.body)\n    return reloadedDocument\n  }\n\n  #updateBody(newBody) {\n    Idiomorph.morph(document.body, newBody)\n  }\n\n  async #reloadStimulus() {\n    await StimulusReloader.reloadAll()\n  }\n}\n","import { log } from \"../logger.js\"\nimport { cacheBustedUrl, reloadHtmlDocument, pathWithoutAssetDigest } from \"../helpers.js\"\n\nexport class CssReloader {\n  static async reload(...params) {\n    return new CssReloader(...params).reload()\n  }\n\n  constructor(filePattern = /./) {\n    this.filePattern = filePattern\n  }\n\n  async reload() {\n    log(\"Reload css...\")\n    await Promise.all(await this.#reloadAllLinks())\n  }\n\n  async #reloadAllLinks() {\n    const cssLinks = await this.#loadNewCssLinks();\n    return cssLinks.map(link => this.#reloadLinkIfNeeded(link))\n  }\n\n  async #loadNewCssLinks() {\n    const reloadedDocument = await reloadHtmlDocument()\n    return Array.from(reloadedDocument.head.querySelectorAll(\"link[rel='stylesheet']\"))\n  }\n\n  #reloadLinkIfNeeded(link) {\n    if (this.#shouldReloadLink(link)) {\n      return this.#reloadLink(link)\n    } else {\n      return Promise.resolve()\n    }\n  }\n\n  #shouldReloadLink(link) {\n    return this.filePattern.test(link.getAttribute(\"href\"))\n  }\n\n  async #reloadLink(link) {\n    return new Promise(resolve => {\n      const href = link.getAttribute(\"href\")\n      const newLink = this.#findExistingLinkFor(link) || this.#appendNewLink(link)\n\n      newLink.setAttribute(\"href\", cacheBustedUrl(link.getAttribute(\"href\")))\n      newLink.onload = () => {\n        log(`\\t${href}`)\n        resolve()\n      }\n    })\n  }\n\n  #findExistingLinkFor(link) {\n    return this.#cssLinks.find(newLink => pathWithoutAssetDigest(link.href) === pathWithoutAssetDigest(newLink.href))\n  }\n\n  get #cssLinks() {\n    return Array.from(document.querySelectorAll(\"link[rel='stylesheet']\"))\n  }\n\n  #appendNewLink(link) {\n    document.head.append(link)\n    return link\n  }\n}\n","import { log } from \"../logger.js\"\n\nexport class ReplaceHtmlReloader {\n  static async reload() {\n    return new ReplaceHtmlReloader().reload()\n  }\n\n  async reload() {\n    await this.#reloadHtml()\n  }\n\n  async #reloadHtml() {\n    log(\"Reload html with Turbo...\")\n\n    this.#keepScrollPosition()\n    await this.#visitCurrentPage()\n  }\n\n  #keepScrollPosition() {\n    document.addEventListener(\"turbo:before-render\", () => {\n      Turbo.navigator.currentVisit.scrolled = true\n    }, { once: true })\n  }\n\n  #visitCurrentPage() {\n    return new Promise(resolve => {\n      document.addEventListener(\"turbo:load\", () => resolve(document), { once: true })\n      window.Turbo.visit(window.location)\n    })\n  }\n}\n","import consumer from \"./consumer\"\nimport { assetNameFromPath } from \"../helpers.js\";\nimport { MorphHtmlReloader } from \"../reloaders/morph_html_reloader.js\";\nimport { CssReloader } from \"../reloaders/css_reloader.js\";\nimport { StimulusReloader } from \"../reloaders/stimulus_reloader.js\";\nimport { ReplaceHtmlReloader } from \"../reloaders/replace_html_reloader.js\";\n\nconsumer.subscriptions.create({ channel: \"Hotwire::Spark::Channel\" }, {\n  connected() {\n    document.body.setAttribute(\"data-hotwire-spark-ready\", \"\")\n  },\n\n  async received(message) {\n    try {\n      await this.dispatch(message)\n    } catch(error) {\n      console.log(`Error on ${message.action}`, error)\n    }\n  },\n\n  dispatch({ action, path }) {\n    switch(action) {\n      case \"reload_html\":\n        return this.reloadHtml()\n      case \"reload_css\":\n        return this.reloadCss(path)\n      case \"reload_stimulus\":\n        return this.reloadStimulus(path)\n      default:\n        throw new Error(`Unknown action: ${action}`)\n    }\n  },\n\n  reloadHtml() {\n    const htmlReloader = HotwireSpark.config.htmlReloadMethod == \"morph\" ? MorphHtmlReloader : ReplaceHtmlReloader\n    return htmlReloader.reload()\n  },\n\n  reloadCss(path) {\n    const fileName = assetNameFromPath(path)\n    return CssReloader.reload(new RegExp(fileName))\n  },\n\n  reloadStimulus(path) {\n    return StimulusReloader.reload(path)\n  }\n})\n\n","import config from \"./config.js\"\nimport \"./channels/monitoring_channel.js\"\n\nconst HotwireSpark = {\n  config: config,\n}\n\nexport default HotwireSpark\n"],"names":["pathWithoutAssetDigest","path","replace","urlWithParams","urlString","params","url","URL","window","location","origin","Object","entries","forEach","_ref","key","value","searchParams","set","toString","cacheBustedUrl","reload","Date","now","async","reloadHtmlDocument","currentUrl","href","hotwire_spark","response","fetch","headers","Accept","ok","Error","status","fetchedHTML","text","DOMParser","parseFromString","getConfigurationProperty","name","document","querySelector","content","config","loggingEnabled","htmlReloadMethod","cableServerPath","adapters","logger","console","undefined","WebSocket","log","messages","this","enabled","push","getTime","secondsSince","time","ConnectionMonitor","constructor","connection","visibilityDidChange","bind","reconnectAttempts","start","isRunning","startedAt","stoppedAt","startPolling","addEventListener","staleThreshold","stop","stopPolling","removeEventListener","recordMessage","pingedAt","recordConnect","disconnectedAt","recordDisconnect","poll","clearTimeout","pollTimeout","setTimeout","reconnectIfStale","getPollInterval","reconnectionBackoffRate","Math","pow","min","random","connectionIsStale","refreshedAt","disconnectedRecently","reopen","visibilityState","isOpen","INTERNAL","message_types","welcome","disconnect","ping","confirmation","rejection","disconnect_reasons","unauthorized","invalid_request","server_restart","remote","default_mount_path","protocols","supportedProtocols","slice","length","indexOf","Connection","consumer","open","subscriptions","monitor","disconnected","send","data","webSocket","JSON","stringify","isActive","getState","socketProtocols","subprotocols","uninstallEventHandlers","installEventHandlers","close","allowReconnect","error","reopenDelay","getProtocol","protocol","isState","triedToReconnect","isProtocolSupported","call","states","state","readyState","toLowerCase","eventName","events","handler","prototype","message","event","identifier","reason","reconnect","type","parse","reconnectAttempted","confirmSubscription","notify","reconnected","reject","notifyAll","willAttemptReconnect","Subscription","mixin","object","properties","extend","perform","action","command","unsubscribe","remove","SubscriptionGuarantor","pendingSubscriptions","guarantee","subscription","startGuaranteeing","forget","filter","s","stopGuaranteeing","retrySubscribing","retryTimeout","subscribe","map","Subscriptions","guarantor","create","channelName","channel","add","ensureActiveConnection","findAll","sendCommand","callbackName","args","Consumer","_url","test","a","createElement","createWebSocketURL","connect","addSubProtocol","subprotocol","element","head","getAttribute","getConfig","createConsumer","Idiomorph","EMPTY_SET","Set","defaults","morphStyle","callbacks","beforeNodeAdded","noOp","afterNodeAdded","beforeNodeMorphed","afterNodeMorphed","beforeNodeRemoved","afterNodeRemoved","beforeAttributeUpdated","style","shouldPreserve","elt","shouldReAppend","shouldRemove","afterHeadMorphed","morphNormalizedContent","oldNode","normalizedNewContent","ctx","block","oldHead","newHead","promises","handleHeadElement","Promise","all","then","assign","ignore","morphChildren","children","bestMatch","newContent","currentElement","firstChild","bestElement","score","newScore","scoreElement","nextSibling","findBestNodeMatch","previousSibling","morphedNode","morphOldNodeTo","stack","added","node","pop","parentElement","insertBefore","insertSiblings","ignoreValueOfActiveElement","possibleActiveElement","ignoreActiveValue","activeElement","ignoreActive","isSoftMatch","HTMLHeadElement","from","to","nodeType","fromAttributes","attributes","toAttributes","fromAttribute","ignoreAttribute","setAttribute","i","toAttribute","hasAttribute","removeAttribute","nodeValue","HTMLInputElement","fromValue","toValue","syncBooleanAttribute","HTMLOptionElement","HTMLTextAreaElement","syncInputValue","syncNodeFrom","replaceChild","newParent","oldParent","newChild","nextNewChild","insertionPoint","appendChild","removeIdsFromConsideration","isIdSetMatch","idSetMatch","findIdSetMatch","removeNodesBetween","softMatch","findSoftMatch","tempNode","removeNode","attr","updateType","attributeName","ignoreUpdate","newHeadTag","currentHead","removed","preserved","nodesToAppend","headMergeStyle","srcToNewHeadNodes","Map","newHeadChild","outerHTML","currentHeadElt","inNewContent","has","isReAppended","isPreserved","delete","values","newNode","newElt","createRange","createContextualFragment","src","resolve","promise","_resolve","removedElement","removeChild","kept","node1","node2","tagName","id","getIdIntersectionCount","startInclusive","endExclusive","newChildPotentialIdCount","potentialMatch","otherMatchCount","potentialSoftMatch","siblingSoftMatchCount","isIdInConsideration","deadIds","idIsWithinNode","targetNode","idMap","get","idSet","sourceSet","matchCount","populateIdMapForNode","nodeParent","idElements","querySelectorAll","current","createIdMap","oldContent","morph","Document","documentElement","parser","contentWithSvgsRemoved","match","generatedByIdiomorph","htmlElement","body","parseContent","normalizedContent","Node","dummyParent","append","normalizeContent","finalConfig","mergeDefaults","target","createMorphContext","_len","arguments","Array","_key","StimulusReloader","changedFilePath","reloadAll","Stimulus","controllers","controller","unload","register","application","reloadChangedStimulusControllers","unloadDeletedStimulusControllers","stimulusControllerPathsToReload","reloadStimulusController","moduleName","controllerPathsToReload","stimulusControllerPaths","shouldReloadController","keys","stimulusPathsByModule","endsWith","extractControllerName","changedControllerIdentifier","pathsByModule","parseImportmapJson","importmapScript","imports","controllerName","pathForModuleName","module","import","registerController","controllersToUnload","deregisterController","didChangeTriggerAReload","default","MorphHtmlReloader","reloadHtml","reloadStimulus","reloadedDocument","updateBody","newBody","CssReloader","filePattern","reloadAllLinks","loadNewCssLinks","link","reloadLinkIfNeeded","shouldReloadLink","reloadLink","newLink","findExistingLinkFor","appendNewLink","onload","cssLinks","find","ReplaceHtmlReloader","keepScrollPosition","visitCurrentPage","Turbo","navigator","currentVisit","scrolled","once","visit","connected","received","dispatch","reloadCss","HotwireSpark","fileName","split","assetNameFromPath","RegExp"],"mappings":"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","x_google_ignoreList":[2,4]}